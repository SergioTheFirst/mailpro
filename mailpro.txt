========================= ДЕРЕВО ПАПОК =========================

mailpro/
├── .gitignore
├── CONSTITUTION.md
├── README.md
├── h origin main
├── mailbot_v26
│   ├── __init__.py
│   ├── __main__.py
│   ├── audit_project.py
│   ├── bot_core
│   │   ├── __init__.py
│   │   ├── action_engine.py
│   │   ├── classifier.py
│   │   ├── extractors
│   │   │   ├── doc.py
│   │   │   ├── excel.py
│   │   │   └── pdf.py
│   │   ├── llm_client.py
│   │   ├── message_processor.py
│   │   ├── prompts
│   │   │   ├── extract_facts.txt
│   │   │   └── verify_facts.txt
│   │   ├── telegram_sender.py
│   │   └── validation.py
│   ├── config
│   │   ├── accounts.ini
│   │   ├── config.ini
│   │   └── keys.ini
│   ├── config_loader.py
│   ├── consistency_audit.py
│   ├── formatter.py
│   ├── imap_client.py
│   ├── mailbot.log
│   ├── pipeline
│   │   ├── __init__.py
│   │   └── processor.py
│   ├── python
│   ├── requirements.txt
│   ├── run_mailbot.bat
│   ├── start.py
│   ├── state.json
│   ├── state_manager.py
│   ├── tests
│   │   ├── conftest.py
│   │   ├── test_config_loader.py
│   │   ├── test_main_entrypoint.py
│   │   ├── test_pipeline_processor.py
│   │   ├── test_state_manager.py
│   │   └── test_telegram_sender.py
│   └── worker
│       └── telegram_sender.py
├── mailpro.txt
├── patch.diff
└── requirements.txt


==================== СОДЕРЖИМОЕ PY-ФАЙЛОВ ====================


========== содержимое файла mailbot_v26\__main__.py ==========

from mailbot_v26.start import main


if __name__ == "__main__":
    main()


------------------------------------------------------------

========== содержимое файла mailbot_v26\audit_project.py ==========

"""
Audit-скрипт для MailBot v26.

Проверяет:
- отсутствие использования запрещённых EXE-строк в КОДЕ
- отсутствие прямых импортов torch/tensorflow/stanza/spacy/transformers
- отсутствие использования catdoc/xlhtml/pdftotext в Python-файлах

ВАЖНО:
Сам audit НЕ содержит запрещённых слов напрямую.
Поэтому строки для проверки собираются динамически.
"""

from __future__ import annotations
from pathlib import Path
import re

PROJECT_ROOT = Path(__file__).resolve().parent

# Формируем запрещённые строки так, чтобы они НЕ находились в исходнике audit'а
BAD1 = "pd" + "ftotext"
BAD2 = "cat" + "doc"
BAD3 = "xl" + "html"

FORBIDDEN_STRINGS = [BAD1, BAD2, BAD3]

FORBIDDEN_IMPORTS = [
    r"\bimport\s+torch\b",
    r"\bfrom\s+torch\b",
    r"\bimport\s+tensorflow\b",
    r"\bimport\s+spacy\b",
    r"\bimport\s+stanza\b",
    r"\bimport\s+transformers\b",
]

def scan_code() -> list[str]:
    problems = []
    for file in PROJECT_ROOT.rglob("*.py"):
        if file.name == "audit_project.py":
            continue  # не проверяем самого себя

        text = file.read_text("utf-8", errors="ignore").lower()

        # 1. Запрещённые exe-строки
        for bad in FORBIDDEN_STRINGS:
            if bad in text:
                problems.append(f"ERROR: В файле {file} найдено запрещённое слово: {bad}")

        # 2. Запрещённые импорты
        for pattern in FORBIDDEN_IMPORTS:
            if re.search(pattern, text):
                problems.append(
                    f"ERROR: В файле {file} найден запрещённый импорт: {pattern}"
                )

    return problems


def main():
    print("=== MailBot v26 Audit ===")
    print(f"Проект: {PROJECT_ROOT}")

    problems = scan_code()
    if not problems:
        print("OK: Запрещённые зависимости не обнаружены.")
        return 0

    print("\nОТЧЁТ:")
    for p in problems:
        print(p)

    print("\nИТОГ: ERROR: Исправь нарушения перед запуском.")
    return 1


if __name__ == "__main__":
    raise SystemExit(main())


------------------------------------------------------------

========== содержимое файла mailbot_v26\bot_core\action_engine.py ==========

"""Lightweight regex-based action extractor (Guaranteed Mode)."""
from __future__ import annotations

import re
from dataclasses import dataclass
from typing import Optional


@dataclass
class ActionFacts:
    action: Optional[str]
    amount: Optional[str]
    date: Optional[str]
    doc_number: Optional[str]
    urgency: Optional[str]
    confidence: float


_AMOUNT_RE = re.compile(r"(?P<amount>\d+[\d\s]*[\.,]?\d*)\s*(?P<currency>₽|руб|рублей|usd|eur|€|\$)?", re.IGNORECASE)
_DATE_RE = re.compile(r"(\d{1,2}[./-]\d{1,2}[./-]\d{2,4})")
_DOC_RE = re.compile(r"(?:№|no\.?|num(?:ber)?)[\s:]*([A-Za-z0-9_-]{3,})", re.IGNORECASE)
_ACTION_RE = re.compile(r"(оплатить|оплата|pay|payment|approve|утвердить|подписать)", re.IGNORECASE)
_URGENT_RE = re.compile(r"(срочно|urgent|asap|немедленно)", re.IGNORECASE)


def _confidence_score(found: int, total_checks: int = 5) -> float:
    base = 0.1 if found else 0.0
    scaled = base + (found / max(total_checks, 1))
    return min(1.0, round(scaled, 2))


def analyze_action(text: str) -> ActionFacts:
    """Extract primitive action hints using regex only (<10ms).

    The function intentionally avoids any ML/LLM usage per Constitution
    and returns a conservative confidence score.
    """

    amount_match = _AMOUNT_RE.search(text)
    date_match = _DATE_RE.search(text)
    doc_match = _DOC_RE.search(text)
    action_match = _ACTION_RE.search(text)
    urgency_match = _URGENT_RE.search(text)

    found_fields = sum(
        1
        for match in (amount_match, date_match, doc_match, action_match, urgency_match)
        if match is not None
    )
    confidence = _confidence_score(found_fields)

    amount = None
    if amount_match:
        amount = amount_match.group("amount")
        currency = amount_match.group("currency") or ""
        amount = f"{amount}{currency}".strip()

    date = date_match.group(1) if date_match else None
    doc_number = doc_match.group(1) if doc_match else None
    action = action_match.group(1).lower() if action_match else None
    urgency = urgency_match.group(1).lower() if urgency_match else None

    return ActionFacts(
        action=action,
        amount=amount,
        date=date,
        doc_number=doc_number,
        urgency=urgency,
        confidence=confidence,
    )


__all__ = ["ActionFacts", "analyze_action"]


------------------------------------------------------------

========== содержимое файла mailbot_v26\bot_core\classifier.py ==========

"""Deterministic attachment classifier with Constitution safeguards.

Section IV: attachments are classified purely by heuristics (no ML).
Section II.3: deterministic, low-memory rules only.
Section VIII: guaranteed mode—safe handling of corrupt files.
"""
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple


Category = str

# Extension → category mapping (deterministic, no guessing)
_EXTENSION_MAP: dict[str, Category] = {
    ".pdf": "PDF",
    ".docx": "DOCX",
    ".doc": "DOC",
    ".xlsx": "XLSX",
    ".xls": "XLS",
    ".png": "IMAGE",
    ".jpg": "IMAGE",
    ".jpeg": "IMAGE",
    ".tif": "IMAGE",
    ".tiff": "IMAGE",
    ".bmp": "IMAGE",
    ".gif": "IMAGE",
    ".txt": "TEXT",
}

# MIME → category mapping
_MIME_MAP: dict[str, Category] = {
    "application/pdf": "PDF",
    "application/msword": "DOC",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "DOCX",
    "application/vnd.ms-excel": "XLS",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "XLSX",
    "image/png": "IMAGE",
    "image/jpeg": "IMAGE",
    "image/tiff": "IMAGE",
    "image/gif": "IMAGE",
    "image/bmp": "IMAGE",
    "text/plain": "TEXT",
}

# Magic prefix bytes for quick sniffing
_PDF_MAGIC = b"%PDF-"
_ZIP_MAGIC = b"PK\x03\x04"
_DOC_MAGIC = b"\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1"  # OLE Compound File (legacy DOC/XLS)
_PNG_MAGIC = b"\x89PNG\r\n\x1a\n"
_JPEG_MAGIC = b"\xff\xd8\xff"
_GIF_MAGIC = b"GIF8"
_TIFF_MAGIC = (b"II*\x00", b"MM\x00*")
_TEXT_PRINTABLE = set(range(0x20, 0x7F)) | {0x09, 0x0A, 0x0D}


@dataclass(frozen=True)
class AttachmentProbe:
    filename: str
    mime_type: str = ""
    content_bytes: bytes = b""

    def suffix(self) -> str:
        return Path(self.filename or "").suffix.lower()

    def prefix(self, length: int = 12) -> bytes:
        return (self.content_bytes or b"")[:length]


def classify_attachment(filename: str = "", mime_type: str = "", content_bytes: bytes = b"") -> Category:
    """Classify an attachment without ML.

    Priority order: MIME → extension → magic sniff → text heuristic → UNKNOWN.
    """

    probe = AttachmentProbe(filename=filename or "", mime_type=(mime_type or "").lower(), content_bytes=content_bytes or b"")

    # 1) MIME type (already authoritative)
    if probe.mime_type in _MIME_MAP:
        return _MIME_MAP[probe.mime_type]

    # 2) Extension mapping
    suffix = probe.suffix()
    if suffix in _EXTENSION_MAP:
        return _EXTENSION_MAP[suffix]

    # 3) Magic prefix sniffing (small prefix only)
    head = probe.prefix(16)
    if head.startswith(_PDF_MAGIC):
        return "PDF"
    if head.startswith(_PNG_MAGIC):
        return "IMAGE"
    if head.startswith(_JPEG_MAGIC):
        return "IMAGE"
    if head.startswith(_GIF_MAGIC):
        return "IMAGE"
    if any(head.startswith(sig) for sig in _TIFF_MAGIC):
        return "IMAGE"
    if head.startswith(_DOC_MAGIC):
        # Legacy OLE container: decide between DOC/XLS only if filename hints; else UNKNOWN.
        if suffix == ".doc":
            return "DOC"
        if suffix == ".xls":
            return "XLS"
        return "UNKNOWN"
    if head.startswith(_ZIP_MAGIC):
        # Could be DOCX/XLSX/other ZIP—use filename hint only.
        if suffix == ".docx":
            return "DOCX"
        if suffix == ".xlsx":
            return "XLSX"
        return "UNKNOWN"

    # 4) Light text heuristic for plain text fallbacks
    if head and _looks_like_text(probe.content_bytes):
        return "TEXT"

    return "UNKNOWN"


def classify_by_keywords(filename: str, text_sample: str = "", content_type: str = "") -> Tuple[Category | None, float]:
    """Compatibility wrapper returning deterministic attachment categories.

    Returns (category, confidence) with 1.0 for known deterministic matches,
    or (None, 0.0) when no supported category is detected.
    """

    category = classify_attachment(filename=filename, mime_type=content_type)
    if category == "UNKNOWN":
        return (None, 0.0)
    return (category, 1.0)


def _looks_like_text(data: bytes, sample: int = 256, binary_threshold: float = 0.10) -> bool:
    sample_bytes = data[:sample]
    if not sample_bytes:
        return False
    non_printable = sum(1 for b in sample_bytes if b not in _TEXT_PRINTABLE)
    return (non_printable / len(sample_bytes)) <= binary_threshold


# -------------------- Self-test --------------------

def _self_test_entries() -> List[Tuple[str, str, bytes]]:
    return [
        ("report.pdf", "application/pdf", _PDF_MAGIC + b" test"),
        ("contract.DOCX", "", _ZIP_MAGIC + b"..."),
        ("legacy_form.doc", "application/msword", _DOC_MAGIC + b"..."),
        ("sheet.xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", _ZIP_MAGIC + b"..."),
        ("legacy.xls", "", _DOC_MAGIC + b"..."),
        ("photo.jpeg", "image/jpeg", _JPEG_MAGIC + b"morebytes"),
        ("diagram.png", "", _PNG_MAGIC + b"..."),
        ("notes.txt", "text/plain", b"hello world"),
        ("readme", "", b"Plain ASCII text snippet"),
        ("unknown.bin", "application/octet-stream", b"\x00\x01\x02\x03"),
    ]


def _run_self_test() -> bool:
    entries = _self_test_entries()
    results: List[Tuple[str, Category]] = []
    for name, mime, data in entries:
        category = classify_attachment(filename=name, mime_type=mime, content_bytes=data)
        results.append((name, category))
        print(f"{name:15s} | mime={mime or '-':45s} | -> {category}")

    # Assertions (deterministic expectations)
    assert results[0][1] == "PDF"
    assert results[1][1] == "DOCX"
    assert results[2][1] == "DOC"
    assert results[3][1] == "XLSX"
    assert results[4][1] == "XLS"
    assert results[5][1] == "IMAGE"
    assert results[6][1] == "IMAGE"
    assert results[7][1] == "TEXT"
    assert results[8][1] == "TEXT"
    assert results[9][1] == "UNKNOWN"

    print("\nSelf-test passed: 10/10 deterministic checks")
    return True


if __name__ == "__main__":
    _run_self_test()


------------------------------------------------------------

========== содержимое файла mailbot_v26\bot_core\extractors\doc.py ==========

from __future__ import annotations

import io


def _load_docx_parser():
    try:
        from docx import Document  # type: ignore

        return Document
    except Exception:
        return None


def _load_docx2txt():
    try:
        import docx2txt  # type: ignore

        return docx2txt
    except Exception:
        return None


def extract_doc(file_bytes: bytes, filename: str) -> str:
    name = (filename or "").lower()

    if name.endswith((".docx", ".docm")):
        document_cls = _load_docx_parser()
        if document_cls is None:
            return ""
        try:
            doc = document_cls(io.BytesIO(file_bytes))
            return "\n".join(
                p.text for p in doc.paragraphs if p.text and p.text.strip()
            )
        except Exception:
            return ""

    if name.endswith(".doc"):
        docx2txt = _load_docx2txt()
        if docx2txt is None:
            return ""
        try:
            return docx2txt.process(io.BytesIO(file_bytes))
        except Exception:
            return ""

    return ""


extract_docx_text = extract_doc


------------------------------------------------------------

========== содержимое файла mailbot_v26\bot_core\extractors\excel.py ==========

from __future__ import annotations

import io


def _load_pandas():
    try:
        import pandas as pd  # type: ignore

        return pd
    except Exception:
        return None


def extract_excel(file_bytes: bytes, filename: str) -> str:
    name = (filename or "").lower()

    if not name.endswith((".xls", ".xlsx")):
        return ""

    pandas = _load_pandas()
    if pandas is None:
        return ""

    try:
        df = pandas.read_excel(io.BytesIO(file_bytes), engine="openpyxl")
        return df.to_string(index=False, header=True)
    except Exception:
        return ""


extract_excel_text = extract_excel


------------------------------------------------------------

========== содержимое файла mailbot_v26\bot_core\extractors\pdf.py ==========

"""
PDF extractor for MailBot v26.

DLL-free, Windows-friendly, RAM-safe.

Использует только:
- pypdf (основной путь для текстовых PDF)
- pikepdf (fallback для странных/частично сломанных PDF)
- опционально OCR через EasyOCR (если RAM позволяет)

Соответствует КОНСТИТУЦИИ:
- никаких pdftotext.exe / poppler / внешних DLL
- только чистый Python и pip-зависимости
- OCR включается ТОЛЬКО при достаточном объёме свободной RAM
"""

from __future__ import annotations

import io
import logging
from typing import Optional, List

try:
    from pypdf import PdfReader
except ImportError:  # fail-safe, обработаем ниже
    PdfReader = None  # type: ignore

try:
    import pikepdf
except ImportError:
    pikepdf = None  # type: ignore


logger = logging.getLogger(__name__)


def _safe_join(chunks: List[str], limit: int = 50_000) -> str:
    """Аккуратно склеивает куски текста с жёстким лимитом длины."""
    out: List[str] = []
    total = 0
    for part in chunks:
        if not part:
            continue
        remaining = limit - total
        if remaining <= 0:
            break
        if len(part) > remaining:
            out.append(part[:remaining])
            total += remaining
            break
        out.append(part)
        total += len(part)
    return "\n".join(out)


def _extract_with_pypdf(file_bytes: bytes) -> str:
    """Попытаться вытащить текст с помощью pypdf."""
    if PdfReader is None:
        return ""

    try:
        reader = PdfReader(io.BytesIO(file_bytes))
    except Exception as e:
        logger.warning("pypdf open failed: %s", e)
        return ""

    chunks: List[str] = []
    for page in reader.pages:
        try:
            txt = page.extract_text() or ""
        except Exception as e:
            logger.debug("pypdf page extract failed: %s", e)
            txt = ""
        if txt.strip():
            chunks.append(txt)

    text = _safe_join(chunks, limit=50_000)
    return text


def _extract_with_pikepdf(file_bytes: bytes) -> str:
    """Fallback-доставка: пробуем pikepdf, если pypdf не дал текста."""
    if pikepdf is None:
        return ""

    try:
        pdf = pikepdf.open(io.BytesIO(file_bytes))
    except Exception as e:
        logger.warning("pikepdf open failed: %s", e)
        return ""
    chunks: List[str] = []

    try:
        for page in pdf.pages:
            try:
                # это очень грубый способ, но иногда вытаскивает текст
                contents = page.get("/Contents", None)
                if contents is None:
                    continue
                s = str(contents)
                if s.strip():
                    chunks.append(s)
            except Exception:
                continue
    finally:
        pdf.close()

    return _safe_join(chunks, limit=50_000)


def _ocr_pdf_if_possible(file_bytes: bytes) -> str:
    """OCR disabled per CONSTITUTION (torch forbidden)."""
    return ""


def extract_pdf(file_bytes: bytes, filename: str) -> str:
    """
    Главная точка входа.

    Порядок:
    1. pypdf — быстрый, дешёвый, для 90% PDF
    2. pikepdf — fallback для странных/сломаных PDF
    3. EasyOCR — только если RAM ≥ 800 МБ и два первых способа дали пустоту
    """
    name = (filename or "").lower()
    if not name.endswith(".pdf"):
        # Защита от неправильного вызова
        return ""

    # 1. pypdf
    text = _extract_with_pypdf(file_bytes)
    if text.strip():
        return text

    # 2. pikepdf fallback
    text = _extract_with_pikepdf(file_bytes)
    if text.strip():
        return text

    # 3. OCR как последний шанс
    ocr_text = _ocr_pdf_if_possible(file_bytes)
    return ocr_text or ""


extract_pdf_text = extract_pdf


------------------------------------------------------------

========== содержимое файла mailbot_v26\bot_core\llm_client.py ==========

"""Cloudflare AI client wrapper.

The client is deliberately lightweight and defensive. If credentials are
missing or a request fails, the caller receives an empty string to keep
pipeline stability, satisfying Constitution Section VI.1.
"""
from __future__ import annotations

import json
import urllib.error
import urllib.request
from dataclasses import dataclass
from pathlib import Path


@dataclass
class CloudflareConfig:
    account_id: str
    api_token: str
    model: str = "@cf/meta/llama-3-8b-instruct"


class CloudflareLLMClient:
    """Minimal Cloudflare AI REST client."""

    def __init__(self, config: CloudflareConfig) -> None:
        self.config = config

    def _build_request(self, prompt: str, data: str) -> urllib.request.Request:
        url = (
            f"https://api.cloudflare.com/client/v4/accounts/"
            f"{self.config.account_id}/ai/run/{self.config.model}"
        )
        payload = json.dumps(
            {
                "messages": [
                    {"role": "system", "content": prompt},
                    {"role": "user", "content": data},
                ]
            }
        ).encode("utf-8")

        request = urllib.request.Request(url, data=payload, method="POST")
        request.add_header("Authorization", f"Bearer {self.config.api_token}")
        request.add_header("Content-Type", "application/json")
        return request

    def generate(self, prompt: str, data: str) -> str:
        """Return model output or empty string on failure."""
        if not self.config.account_id or not self.config.api_token:
            return ""

        try:
            request = self._build_request(prompt, data)
            with urllib.request.urlopen(request, timeout=15) as response:
                body = response.read().decode("utf-8")
            parsed = json.loads(body)
            choices = parsed.get("result", {}).get("response", {})
            if isinstance(choices, dict) and "message" in choices:
                content = choices["message"].get("content", "")
            else:
                content = parsed.get("result", {}).get("output", "")
            if isinstance(content, list):
                content = "".join(str(part) for part in content)
            return str(content).strip()
        except (urllib.error.URLError, json.JSONDecodeError, KeyError, TimeoutError, ValueError):
            return ""


def load_prompt(path: Path) -> str:
    return path.read_text(encoding="utf-8").strip()


------------------------------------------------------------

========== содержимое файла mailbot_v26\bot_core\message_processor.py ==========

"""Core document processing pipeline for MailBot v26."""
from __future__ import annotations

import re
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List

from ..config_loader import BotConfig
from ..formatter import format_summary
from ..state_manager import StateManager
from .action_engine import analyze_action
from .classifier import classify_by_keywords
from .llm_client import CloudflareConfig, CloudflareLLMClient, load_prompt
from .validation import drop_none_tokens, ensure_length, is_confident_score


@dataclass
class Attachment:
    filename: str
    content: bytes
    content_type: str = ""


@dataclass
class InboundMessage:
    subject: str
    body: str
    attachments: List[Attachment]


_AMOUNT_RE = re.compile(r"(?P<amount>\d+[\d\s]*[\.,]?\d*)\s*(?P<currency>₽|руб|рублей|usd|eur|€|\$)?", re.IGNORECASE)
_DATE_RE = re.compile(r"(\d{1,2}[./-]\d{1,2}[./-]\d{2,4})")


class MessageProcessor:
    """Sequential extraction → classification → fact validation."""

    def __init__(self, config: BotConfig, state: StateManager, base_dir: Path | None = None) -> None:
        self.config = config
        self.state = state
        self.base_dir = base_dir or Path(__file__).resolve().parent
        cf_config = CloudflareConfig(
            account_id=config.keys.cf_account_id,
            api_token=config.keys.cf_api_token,
        )
        self.llm = CloudflareLLMClient(cf_config)
        self.prompt_extract = load_prompt(self.base_dir / "prompts" / "extract_facts.txt")
        self.prompt_verify = load_prompt(self.base_dir / "prompts" / "verify_facts.txt")

    def process(self, account_login: str, message: InboundMessage) -> str:
        text = self._collect_text(message)
        action_summary, action_confidence = self._try_action_engine(text)
        if action_confidence >= 0.7 and action_summary:
            clipped = ensure_length(action_summary)
            return format_summary([clipped])
        doc_type, score = classify_by_keywords(
            filename=" ".join(att.filename for att in message.attachments),
            text_sample=text,
        )
        if not is_confident_score(score):
            doc_type = doc_type or "general"
        facts = self._extract_facts(text)
        verified = self._verify_facts(facts, text)
        cleaned = drop_none_tokens(verified)
        clipped = ensure_length(cleaned or message.subject)
        if doc_type and cleaned:
            clipped = ensure_length(f"{clipped} | #{doc_type}")
        return format_summary([clipped])

    def _try_action_engine(self, text: str) -> tuple[str, float]:
        facts = analyze_action(text)
        parts = []
        if facts.action:
            parts.append(f"ДЕЙСТВИЕ: {facts.action}")
        if facts.amount:
            parts.append(f"СУММА: {facts.amount}")
        if facts.date:
            parts.append(f"СРОК: {facts.date}")
        if facts.doc_number:
            parts.append(f"ДОКУМЕНТ: {facts.doc_number}")
        if facts.urgency:
            parts.append(f"СРОЧНОСТЬ: {facts.urgency}")
        summary = " | ".join(parts)
        return summary, facts.confidence

    def _collect_text(self, message: InboundMessage) -> str:
        parts = [message.subject, message.body]
        parts.extend(self._extract_attachments(message.attachments))
        return "\n".join(part for part in parts if part)

    def _extract_attachments(self, attachments: Iterable[Attachment]) -> List[str]:
        texts: List[str] = []
        for attachment in attachments:
            text = self._extract_by_type(attachment)
            if text:
                texts.append(text)
        return texts

    def _extract_by_type(self, attachment: Attachment) -> str:
        name_lower = (attachment.filename or "").lower()
        from .extractors.pdf import extract_pdf_text  # lazy import
        from .extractors.doc import extract_docx_text
        from .extractors.excel import extract_excel_text

        if name_lower.endswith(".pdf"):
            return extract_pdf_text(attachment.content, attachment.filename)
        if name_lower.endswith(".docx"):
            return extract_docx_text(attachment.content, attachment.filename)
        if name_lower.endswith(".xls") or name_lower.endswith(".xlsx"):
            return extract_excel_text(attachment.content, attachment.filename)
        try:
            return attachment.content.decode("utf-8", errors="ignore")
        except Exception:
            return ""

    def _extract_facts(self, text: str) -> str:
        llm_result = self.llm.generate(self.prompt_extract, text)
        if llm_result:
            return llm_result
        return self._fallback_fact_scan(text)

    def _fallback_fact_scan(self, text: str) -> str:
        amount_match = _AMOUNT_RE.search(text)
        date_match = _DATE_RE.search(text)
        parts: List[str] = []
        if amount_match:
            amount = amount_match.group("amount")
            currency = amount_match.group("currency") or ""
            parts.append(f"СУММА: {amount}{currency}")
        if date_match:
            parts.append(f"СРОК: {date_match.group(1)}")
        return " | ".join(parts) if parts else ""

    def _verify_facts(self, facts_line: str, text: str) -> str:
        if not facts_line:
            return ""
        verified = self.llm.generate(self.prompt_verify, f"Текст:\n{text}\n\nФакты:\n{facts_line}")
        return verified or facts_line


__all__ = ["MessageProcessor", "Attachment", "InboundMessage"]


------------------------------------------------------------

========== содержимое файла mailbot_v26\bot_core\telegram_sender.py ==========

"""Minimal Telegram send helper."""
from __future__ import annotations

import json
import urllib.error
import urllib.parse
import urllib.request


def send_telegram_message(bot_token: str, chat_id: str, text: str) -> bool:
    """Send message via Telegram HTTP API. Returns success flag."""
    if not bot_token or not chat_id or not text:
        return False
    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    payload = urllib.parse.urlencode({"chat_id": chat_id, "text": text})
    request = urllib.request.Request(url, data=payload.encode("utf-8"), method="POST")
    request.add_header("Content-Type", "application/x-www-form-urlencoded")
    try:
        with urllib.request.urlopen(request, timeout=10) as response:
            body = response.read().decode("utf-8")
            parsed = json.loads(body)
            return bool(parsed.get("ok"))
    except (urllib.error.URLError, json.JSONDecodeError, TimeoutError, ValueError):
        return False


__all__ = ["send_telegram_message"]


------------------------------------------------------------

========== содержимое файла mailbot_v26\bot_core\validation.py ==========

"""Validation helpers for post-LLM cleaning."""
from __future__ import annotations

import re
from typing import List


def drop_none_tokens(facts_line: str) -> str:
    """Remove NONE tokens and trim separators."""
    if not facts_line:
        return ""
    tokens = [token.strip() for token in facts_line.split("|") if token.strip()]
    filtered = [t for t in tokens if t.lower() != "none"]
    return " | ".join(filtered).strip()


def clean_none(text: str) -> str:
    """Remove any segment containing NONE (case-insensitive)."""
    if not text:
        return ""
    if text.strip().lower() == "none":
        return ""
    segments = [segment.strip() for segment in text.split("|") if segment.strip()]
    filtered = [segment for segment in segments if "none" not in segment.lower()]
    return " | ".join(filtered)


def _extract_numbers(text: str) -> List[str]:
    return [match.strip() for match in re.findall(r"\d+[\d\s]*[\.,]?\d*", text)]


def validate_numbers(summary: str, original: str) -> bool:
    """Ensure every number in the summary is present in the original text."""
    numbers = _extract_numbers(summary)
    lowered_original = original or ""
    for number in numbers:
        if number not in lowered_original:
            return False
    return True


def _normalize_date(value: str) -> str:
    return re.sub(r"[/-]", ".", value)


STOP_WORDS = {
    "на",
    "до",
    "и",
    "в",
    "к",
    "по",
    "за",
    "с",
    "от",
    "просим",
}


def validate_dates(summary: str, original: str) -> bool:
    date_re = re.compile(r"\d{1,2}[./-]\d{1,2}[./-]\d{2,4}")
    summary_dates = [
        _normalize_date(match) for match in date_re.findall(summary or "")
    ]
    if not summary_dates:
        return True

    original_dates = {
        _normalize_date(match) for match in date_re.findall(original or "")
    }
    return all(date in original_dates for date in summary_dates)


def jaccard_similarity(text1: str, text2: str) -> float:
    def _tokenize(text: str) -> set[str]:
        raw_tokens = re.findall(r"[\w\.]+", (text or "").lower())
        tokens: set[str] = set()
        for raw in raw_tokens:
            token = raw.replace("ё", "е").strip("._")
            while len(token) > 3 and token[-1] in "аеёиоуыэюяй":
                token = token[:-1]
            if not token or token in STOP_WORDS:
                continue
            tokens.add(token)
        return tokens

    tokens1 = _tokenize(text1)
    tokens2 = _tokenize(text2)
    if not tokens1 or not tokens2:
        return 0.0
    intersection = tokens1 & tokens2
    union = tokens1 | tokens2
    return len(intersection) / len(union) if union else 0.0


def validate_summary(summary: str, original: str, min_similarity: float = 0.35) -> str | None:
    cleaned = clean_none(summary)
    if not cleaned:
        return None
    if not validate_numbers(cleaned, original):
        return None
    if not validate_dates(cleaned, original):
        return None
    similarity = jaccard_similarity(cleaned, original)
    if similarity < min_similarity:
        return None
    return cleaned


def ensure_length(text: str, limit: int = 200) -> str:
    """Trim text to the Constitution limit."""
    if not text:
        return ""
    if len(text) <= limit:
        return text
    return text[: limit - 1].rstrip(" |")


def is_confident_score(score: float) -> bool:
    return score >= 0.7


def _self_test():
    original = "Просим оплатить счёт №123 на сумму 150000 рублей до 20.12.2024"
    good = "СУММА: 150000 | СРОК: 20.12.2024 | ДОКУМЕНТ: №123"
    bad = "СУММА: 999000 | СРОК: 01.01.2099 | ДОКУМЕНТ: №999"
    mix = "СУММА: 150000 | СРОК: NONE | ДОКУМЕНТ: №123 | ДЕЙСТВИЕ: оплатить"

    assert clean_none(mix) == "СУММА: 150000 | ДОКУМЕНТ: №123 | ДЕЙСТВИЕ: оплатить"
    assert validate_numbers(good, original) is True
    assert validate_numbers(bad, original) is False
    assert validate_dates(good, original) is True
    assert validate_dates(bad, original) is False

    vs = validate_summary(good, original)
    assert vs is not None

    vs_bad = validate_summary(bad, original)
    assert vs_bad is None

    print("OK: validation self-test passed")


__all__ = [
    "clean_none",
    "drop_none_tokens",
    "ensure_length",
    "is_confident_score",
    "jaccard_similarity",
    "validate_dates",
    "validate_numbers",
    "validate_summary",
]


if __name__ == "__main__":
    _self_test()


------------------------------------------------------------

========== содержимое файла mailbot_v26\config_loader.py ==========

"""Configuration loading utilities for MailBot Premium v26.

This module follows the project Constitution by favoring clarity and
strict validation over implicit defaults. All configuration files are
stored under ``mailbot_v26/config`` and are separated to keep secrets
and per-account settings isolated.
"""

from __future__ import annotations

import configparser
from dataclasses import dataclass
from pathlib import Path
from typing import List

CONFIG_DIR = Path(__file__).resolve().parent / "config"


@dataclass
class GeneralConfig:
    """Top-level bot settings."""

    check_interval: int
    max_attachment_mb: int
    admin_chat_id: str


@dataclass
class AccountConfig:
    """Configuration for a single IMAP account."""

    name: str
    login: str
    password: str
    host: str
    port: int
    use_ssl: bool
    telegram_chat_id: str


@dataclass
class KeysConfig:
    """External service tokens."""

    telegram_bot_token: str
    cf_account_id: str
    cf_api_token: str


@dataclass
class BotConfig:
    """Aggregate configuration bundle."""

    general: GeneralConfig
    accounts: List[AccountConfig]
    keys: KeysConfig


class ConfigError(Exception):
    """Raised when configuration files are missing or invalid."""


def _read_config_file(path: Path) -> configparser.ConfigParser:
    parser = configparser.ConfigParser()
    if not path.exists():
        raise ConfigError(f"Config file not found: {path}")
    parser.read(path, encoding="utf-8")
    return parser


def load_general_config(base_dir: Path = CONFIG_DIR) -> GeneralConfig:
    parser = _read_config_file(base_dir / "config.ini")
    if "general" not in parser:
        raise ConfigError("[general] section missing in config.ini")

    section = parser["general"]
    try:
        return GeneralConfig(
            check_interval=section.getint("check_interval", fallback=180),
            max_attachment_mb=section.getint("max_attachment_mb", fallback=15),
            admin_chat_id=section.get("admin_chat_id", fallback=""),
        )
    except ValueError as exc:  # invalid numbers
        raise ConfigError(f"Invalid value in config.ini: {exc}") from exc


def load_accounts_config(base_dir: Path = CONFIG_DIR) -> List[AccountConfig]:
    parser = _read_config_file(base_dir / "accounts.ini")
    accounts: List[AccountConfig] = []
    for section_name in parser.sections():
        section = parser[section_name]
        try:
            account = AccountConfig(
                name=section_name,
                login=section["login"],
                password=section["password"],
                host=section.get("host", ""),
                port=section.getint("port", fallback=993),
                use_ssl=section.getboolean("use_ssl", fallback=True),
                telegram_chat_id=section.get("telegram_chat_id", fallback=""),
            )
        except KeyError as exc:
            raise ConfigError(f"Missing required field {exc!s} in accounts.ini:{section_name}") from exc
        except ValueError as exc:
            raise ConfigError(f"Invalid numeric field in accounts.ini:{section_name}: {exc}") from exc
        accounts.append(account)

    if not accounts:
        raise ConfigError("No accounts defined in accounts.ini")
    return accounts


def load_keys_config(base_dir: Path = CONFIG_DIR) -> KeysConfig:
    parser = _read_config_file(base_dir / "keys.ini")
    if "telegram" not in parser or "cloudflare" not in parser:
        raise ConfigError("keys.ini must contain [telegram] and [cloudflare] sections")

    telegram = parser["telegram"]
    cloudflare = parser["cloudflare"]
    try:
        return KeysConfig(
            telegram_bot_token=telegram["bot_token"],
            cf_account_id=cloudflare["account_id"],
            cf_api_token=cloudflare["api_token"],
        )
    except KeyError as exc:
        raise ConfigError(f"Missing key in keys.ini: {exc!s}") from exc


def load_config(base_dir: Path = CONFIG_DIR) -> BotConfig:
    """Load and validate all configuration files.

    Parameters
    ----------
    base_dir:
        Optional base directory override. Defaults to ``mailbot_v26/config``.
    """

    general = load_general_config(base_dir)
    accounts = load_accounts_config(base_dir)
    keys = load_keys_config(base_dir)
    return BotConfig(general=general, accounts=accounts, keys=keys)


__all__ = [
    "AccountConfig",
    "BotConfig",
    "ConfigError",
    "GeneralConfig",
    "KeysConfig",
    "load_config",
    "load_accounts_config",
    "load_general_config",
    "load_keys_config",
]


------------------------------------------------------------

========== содержимое файла mailbot_v26\consistency_audit.py ==========

"""Full-project consistency audit aligned with the Constitution.

This module walks the entire ``mailbot_v26`` directory, prints per-file line
counts with one-line summaries, flags empty or unexpected files, detects
potentially unused Python modules, and searches for dependencies banned by
Constitution Section IX. Constitution Sections II and VIII are used as
guardrails for architecture and Guaranteed Mode readiness.
"""

from __future__ import annotations

import argparse
import ast
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, Iterable, List, Set

PROJECT_ROOT = Path(__file__).resolve().parent
PACKAGE_NAME = PROJECT_ROOT.name

FORBIDDEN_DEPENDENCIES: Set[str] = {
    "spacy",
    "stanza",
    "bert",
    "bert-base",
    "bert-large",
    "transformers",
    "torch",
    "tensorflow",
}

ALLOWED_SUFFIXES: Set[str] = {
    ".py",
    ".txt",
    ".ini",
    ".md",
    ".json",
    ".yaml",
    ".yml",
    ".cfg",
    ".conf",
    ".lock",
    ".req",
}

IGNORED_DIR_NAMES: Set[str] = {"__pycache__", ".git", ".venv", ".idea"}


@dataclass
class FileInfo:
    path: Path
    line_count: int
    description: str
    is_empty: bool
    unexpected: bool


@dataclass
class AuditReport:
    files: List[FileInfo] = field(default_factory=list)
    empty_files: List[FileInfo] = field(default_factory=list)
    unexpected_files: List[FileInfo] = field(default_factory=list)
    unused_modules: List[FileInfo] = field(default_factory=list)
    forbidden_dependencies: Set[str] = field(default_factory=set)
    constitution_matches: List[str] = field(default_factory=list)
    constitution_violations: List[str] = field(default_factory=list)


def iter_project_files(base_path: Path) -> Iterable[Path]:
    for path in base_path.rglob("*"):
        if path.is_dir() and path.name in IGNORED_DIR_NAMES:
            continue
        if path.is_file():
            yield path.resolve()


def count_lines(path: Path) -> int:
    try:
        with path.open(encoding="utf-8", errors="ignore") as handle:
            return sum(1 for _ in handle)
    except OSError:
        return 0


def describe_file(path: Path) -> str:
    if path.suffix == ".py":
        try:
            module = ast.parse(path.read_text(encoding="utf-8"))
            doc = ast.get_docstring(module)
            if doc:
                return doc.strip().splitlines()[0]
        except (OSError, SyntaxError):
            pass
    try:
        for line in path.read_text(encoding="utf-8", errors="ignore").splitlines():
            cleaned = line.strip()
            if cleaned:
                return cleaned[:160]
    except OSError:
        return "Unreadable file"
    return "(empty file)"


def is_unexpected_file(path: Path) -> bool:
    if path.name.startswith("."):
        return False
    if path.suffix in ALLOWED_SUFFIXES:
        return False
    return True


def gather_file_infos(base_path: Path) -> List[FileInfo]:
    infos: List[FileInfo] = []
    for path in sorted(iter_project_files(base_path)):
        line_count = count_lines(path)
        description = describe_file(path)
        unexpected = is_unexpected_file(path)
        info = FileInfo(
            path=path,
            line_count=line_count,
            description=description,
            is_empty=line_count == 0,
            unexpected=unexpected,
        )
        infos.append(info)
    return infos


def python_module_name(path: Path) -> str:
    relative = path.with_suffix("").relative_to(PROJECT_ROOT)
    return ".".join([PACKAGE_NAME, *relative.parts])


def collect_python_files(infos: Iterable[FileInfo]) -> List[Path]:
    return [info.path for info in infos if info.path.suffix == ".py"]


def collect_import_targets(py_files: Iterable[Path]) -> Set[str]:
    imports: Set[str] = set()
    for file_path in py_files:
        try:
            tree = ast.parse(file_path.read_text(encoding="utf-8"))
        except (OSError, SyntaxError):
            continue
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.add(alias.name)
            elif isinstance(node, ast.ImportFrom):
                module = node.module or ""
                for alias in node.names:
                    target = module if alias.name == "*" else f"{module}.{alias.name}" if module else alias.name
                    imports.add(target)
    return imports


def detect_unused_modules(infos: List[FileInfo]) -> List[FileInfo]:
    py_files = collect_python_files(infos)
    modules: Dict[str, Path] = {python_module_name(path): path for path in py_files}
    imports = collect_import_targets(py_files)

    unused: List[FileInfo] = []
    for module_name, path in modules.items():
        if path.name == "__init__.py":
            continue
        if path.name.startswith("test_") or "tests" in path.parts:
            continue
        if any(module_name.startswith(target) or target.startswith(module_name) for target in imports):
            continue
        if "__main__" in path.read_text(encoding="utf-8", errors="ignore"):
            continue
        description = describe_file(path)
        unused.append(
            FileInfo(
                path=path,
                line_count=count_lines(path),
                description=description,
                is_empty=False,
                unexpected=False,
            )
        )
    return sorted(unused, key=lambda info: str(info.path))


def detect_forbidden_dependencies(base_path: Path) -> Set[str]:
    detected: Set[str] = set()
    for path in base_path.rglob("requirements*.txt"):
        content = path.read_text(encoding="utf-8", errors="ignore").lower()
        for forbidden in FORBIDDEN_DEPENDENCIES:
            if forbidden in content:
                detected.add(forbidden)
    return detected


def summarize_constitution(report: AuditReport) -> None:
    if not report.unexpected_files and not report.empty_files:
        report.constitution_matches.append(
            "Section II — архитектурная целостность: каталог очищен, пустые и лишние файлы не обнаружены"
        )
    if not report.unused_modules:
        report.constitution_matches.append(
            "Section VIII — Guaranteed Mode: все модули задействованы в рабочем коде или тестах"
        )
    if not report.forbidden_dependencies:
        report.constitution_matches.append(
            "Section IX — запрещённые зависимости: spaCy/Stanza/BERT/seq2seq/NN фреймворки не найдены"
        )

    if report.unexpected_files or report.empty_files:
        report.constitution_violations.append(
            "Section II — найденные пустые или неожиданные файлы требуют очистки"
        )
    if report.unused_modules:
        report.constitution_violations.append(
            "Section VIII — обнаружены потенциально неиспользуемые модули, требуется проверка их роли"
        )
    if report.forbidden_dependencies:
        report.constitution_violations.append(
            "Section IX — найдены запрещённые зависимости, их необходимо удалить"
        )


def build_report(base_path: Path) -> AuditReport:
    infos = gather_file_infos(base_path)
    report = AuditReport()
    report.files = infos
    report.empty_files = [info for info in infos if info.is_empty]
    report.unexpected_files = [info for info in infos if info.unexpected]
    report.unused_modules = detect_unused_modules(infos)
    report.forbidden_dependencies = detect_forbidden_dependencies(base_path)
    summarize_constitution(report)
    return report


def format_file_line(info: FileInfo) -> str:
    return f"{info.path} | {info.line_count:4d} lines | {info.description}"


def print_report(report: AuditReport) -> None:
    print("=== CONSTITUTION CHECK ===")
    print("Section II — Архитектурная целостность")
    print("Section VIII — Guaranteed Mode: ошибки не должны ломать процесс")
    print("Section IX — Запрещённые зависимости")
    print()

    print("=== FILES ===")
    for info in report.files:
        print(format_file_line(info))

    print()
    print("EMPTY FILES:")
    if report.empty_files:
        for info in report.empty_files:
            print(f" - {info.path}")
    else:
        print(" - none")

    print("UNEXPECTED FILES:")
    if report.unexpected_files:
        for info in report.unexpected_files:
            print(f" - {info.path}")
    else:
        print(" - none")

    print("UNUSED MODULES:")
    if report.unused_modules:
        for info in report.unused_modules:
            print(f" - {info.path}")
    else:
        print(" - none")

    print("FORBIDDEN DEPENDENCIES:")
    if report.forbidden_dependencies:
        for item in sorted(report.forbidden_dependencies):
            print(f" - {item}")
    else:
        print(" - none")

    print()
    print("МОДУЛИ СООТВЕТСТВУЮТ КОНСТИТУЦИИ:")
    if report.constitution_matches:
        for line in report.constitution_matches:
            print(f" - {line}")
    else:
        print(" - нет подтверждений")

    print("МОДУЛИ НАРУШАЮТ КОНСТИТУЦИЮ:")
    if report.constitution_violations:
        for line in report.constitution_violations:
            print(f" - {line}")
    else:
        print(" - нет нарушений")


# === SELF-TEST ===

def run_self_test(base_path: Path) -> None:
    report = build_report(base_path)
    print_report(report)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Full project consistency audit")
    parser.add_argument(
        "--root",
        type=Path,
        default=PROJECT_ROOT,
        help="Path to the mailbot_v26 project root (defaults to this file's directory)",
    )
    args = parser.parse_args()
    run_self_test(args.root)


------------------------------------------------------------

========== содержимое файла mailbot_v26\formatter.py ==========

"""Output formatting for compact Telegram-friendly summaries."""

from __future__ import annotations

from typing import Iterable

MAX_LEN = 200


def _trim_segment(segment: str) -> str:
    return segment.strip().replace("\n", " ")


def format_summary(parts: Iterable[str]) -> str:
    filtered = [_trim_segment(p) for p in parts if p and p.strip().upper() != "NONE"]
    summary = " | ".join(filtered)
    return summary[:MAX_LEN]


__all__ = ["format_summary", "MAX_LEN"]


------------------------------------------------------------

========== содержимое файла mailbot_v26\imap_client.py ==========

"""IMAP helper implementing the UID+SINCE hybrid search mandated by the
Constitution. The class is intentionally small so it can be tested with
mocks without opening real network connections.
"""

from __future__ import annotations

import logging
from datetime import datetime, timedelta
from typing import Iterable, List, Sequence

try:  # pragma: no cover - import guard
    from imapclient import IMAPClient
except ModuleNotFoundError:  # pragma: no cover - handled at runtime
    IMAPClient = None  # type: ignore

from .config_loader import AccountConfig
from .state_manager import StateManager


class ResilientIMAP:
    """IMAP client that combines UID and SINCE queries to avoid duplicates."""

    def __init__(self, account: AccountConfig, state: StateManager) -> None:
        self.account = account
        self.state = state
        self.logger = logging.getLogger(__name__)

    def _build_search(self, now: datetime | None = None) -> List[Sequence[str]]:
        last_uid = self.state.get_last_uid(self.account.login)
        last_check = self.state.get_last_check_time(self.account.login)
        if not last_check:
            last_check = (now or datetime.now()) - timedelta(days=1)
        since_date = last_check.strftime("%d-%b-%Y")

        if last_uid <= 0:
            return [["SINCE", since_date]]
        return [["OR", ["UID", f"{last_uid + 1}:*"], ["SINCE", since_date]]]

    def fetch_new_messages(self) -> List[tuple[int, bytes]]:
        criteria = self._build_search()
        if IMAPClient is None:
            self.state.set_imap_status(self.account.login, "error", "imapclient missing")
            self.logger.error("IMAP client dependency is not available; skipping fetch")
            return []
        try:
            client = IMAPClient(self.account.host, port=self.account.port, ssl=self.account.use_ssl)
            client.login(self.account.login, self.account.password)
            client.select_folder("INBOX")
            uids: Iterable[int] = client.search(criteria[0])
            last_uid = self.state.get_last_uid(self.account.login)
            new_uids = [uid for uid in uids if uid > last_uid]
            messages: List[tuple[int, bytes]] = []
            for uid in sorted(new_uids):
                data = client.fetch([uid], ["RFC822"])
                raw: bytes = data[uid][b"RFC822"]
                messages.append((uid, raw))
            if messages:
                self.state.update_last_uid(self.account.login, messages[-1][0])
            self.state.update_check_time(self.account.login)
            self.state.set_imap_status(self.account.login, "ok")
            return messages
        except Exception as exc:  # network/imap errors should not crash pipeline
            self.state.set_imap_status(self.account.login, "error", str(exc))
            self.logger.exception("IMAP fetch failed for %s", self.account.login)
            return []


__all__ = ["ResilientIMAP"]


------------------------------------------------------------

========== содержимое файла mailbot_v26\pipeline\processor.py ==========

"""Pipeline processor with validation and final formatting."""
from __future__ import annotations

import re
import sys
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import List, Optional

if __name__ == "__main__" and __package__ is None:
    sys.path.append(str(Path(__file__).resolve().parents[2]))

from mailbot_v26.bot_core import validation
from mailbot_v26.config_loader import BotConfig
from mailbot_v26.state_manager import StateManager

_AMOUNT_RE = re.compile(r"(?P<amount>\d+[\d\s]*[\.,]?\d*)\s*(?P<currency>₽|руб|рублей|usd|eur|€|\$)?", re.IGNORECASE)
_DATE_RE = re.compile(r"(\d{1,2}[./-]\d{1,2}[./-]\d{2,4})")
_ACTION_KEYWORDS = ["оплат", "оплатить", "подписать", "согласовать", "отправить", "доставить", "ожидается"]


@dataclass
class Message:
    subject: str
    body: str
    attachments: List[str] | None = None


@dataclass
class FactSummary:
    amount: Optional[str] = None
    date: Optional[str] = None
    action: Optional[str] = None
    doc_type: Optional[str] = None


class PipelineProcessor:
    """Sequential pipeline covering extraction→classification→validation."""

    def __init__(self, config: BotConfig, state: StateManager) -> None:
        self.config = config
        self.state = state

    def process(self, account_login: str, message: Message) -> str:
        text = self._extract_text(message)
        doc_type = self._classify(text)
        facts = self._extract_facts(text)
        facts.doc_type = doc_type
        facts = self._validate(facts, text)
        facts_line = self._facts_to_line(facts)
        validated = validation.validate_summary(facts_line, text)
        has_key_facts = any([facts.amount, facts.date, facts.action])
        fallback_summary = facts_line if facts_line and has_key_facts else None
        final_msg = build_final_message(message.subject, validated or fallback_summary)
        return final_msg

    def _extract_text(self, message: Message) -> str:
        parts: List[str] = [message.subject, message.body]
        if message.attachments:
            parts.extend(message.attachments)
        return "\n".join(filter(None, parts))

    def _classify(self, text: str) -> str:
        lowered = text.lower()
        if any(word in lowered for word in ["счет", "счёт", "invoice", "к оплате"]):
            return "invoice"
        if any(word in lowered for word in ["договор", "contract"]):
            return "contract"
        if any(word in lowered for word in ["акт", "delivery", "отгруз"]):
            return "act"
        return "general"

    def _extract_facts(self, text: str) -> FactSummary:
        amount_match = _AMOUNT_RE.search(text)
        date_match = _DATE_RE.search(text)
        action = self._find_action(text)
        amount = None
        if amount_match:
            amount = amount_match.group("amount")
            currency = amount_match.group("currency")
            if currency:
                amount = f"{amount}{currency}".replace(" ", "")
        date_value = None
        if date_match:
            try:
                parsed = datetime.strptime(date_match.group(1), "%d.%m.%Y")
                date_value = parsed.strftime("%d.%m.%Y")
            except ValueError:
                date_value = date_match.group(1)
        return FactSummary(amount=amount, date=date_value, action=action)

    def _find_action(self, text: str) -> Optional[str]:
        lowered = text.lower()
        for keyword in _ACTION_KEYWORDS:
            if keyword in lowered:
                return keyword
        return None

    def _validate(self, facts: FactSummary, text: str) -> FactSummary:
        lowered = text.lower()
        if facts.action and any(neg in lowered for neg in ["не", "отмена", "cancel"]):
            facts.action = None
        return facts

    def _facts_to_line(self, facts: FactSummary) -> str:
        parts: List[str] = []
        if facts.amount:
            parts.append(f"СУММА: {facts.amount}")
        if facts.date:
            parts.append(f"СРОК: {facts.date}")
        if facts.action:
            parts.append(f"ДЕЙСТВИЕ: {facts.action}")
        if facts.doc_type:
            parts.append(f"ДОКУМЕНТ: {facts.doc_type}")
        return " | ".join(parts)


def build_final_message(subject: str, facts_str: str | None) -> str:
    facts_str = (facts_str or "").strip()
    if not facts_str:
        return ""

    clean_subject = (subject or "").strip()
    if clean_subject:
        base_message = f"SUBJECT: {clean_subject} | FACTS: {facts_str}"
    else:
        base_message = f"FACTS: {facts_str}"

    assert "none" not in base_message.lower()
    if len(base_message) > 240:
        return base_message[:240]
    return base_message


__all__ = ["PipelineProcessor", "Message", "FactSummary", "build_final_message"]


def _self_test_build_final_message():
    subject = "Оплата счёта"
    original = "Просим оплатить счёт №123 на сумму 150000 рублей до 20.12.2024"
    facts = "СУММА: 150000 | СРОК: 20.12.2024 | ДОКУМЕНТ: №123 | ДЕЙСТВИЕ: оплатить"

    valid = validation.validate_summary(facts, original)
    final = build_final_message(subject, valid)

    assert final.startswith("SUBJECT:")
    assert "none" not in final.lower()
    assert len(final) <= 240

    print("OK: build_final_message self-test passed")


if __name__ == "__main__":
    _self_test_build_final_message()


------------------------------------------------------------

========== содержимое файла mailbot_v26\start.py ==========

"""MailBot Premium v26 - Runtime orchestrator"""
from __future__ import annotations

import logging
import sys
import time
from email import message_from_bytes
from email.header import decode_header, make_header
from email.message import Message as EmailMessage
from pathlib import Path
from typing import List

CURRENT_DIR = Path(__file__).resolve().parent
LOG_PATH = CURRENT_DIR / "mailbot.log"


def _configure_logging() -> None:
    handlers: List[logging.Handler] = []
    try:
        LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
        file_handler = logging.FileHandler(LOG_PATH, encoding="utf-8")
        handlers.append(file_handler)
    except OSError as exc:
        print(f"File logging unavailable: {exc}")
    
    handlers.append(logging.StreamHandler(sys.stdout))
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s",
        handlers=handlers,
        force=True
    )


_configure_logging()
logger = logging.getLogger("mailbot")

# Добавляем родительскую папку в путь для импортов
sys.path.insert(0, str(CURRENT_DIR.parent))

from mailbot_v26.config_loader import BotConfig, load_config
from mailbot_v26.imap_client import ResilientIMAP
from mailbot_v26.state_manager import StateManager
from mailbot_v26.bot_core.message_processor import Attachment, InboundMessage, MessageProcessor
from mailbot_v26.worker.telegram_sender import send_telegram


def _decode_subject(email_obj: EmailMessage) -> str:
    raw_subject = email_obj.get("Subject", "")
    try:
        return str(make_header(decode_header(raw_subject)))
    except Exception:
        return raw_subject or ""


def _extract_body(email_obj: EmailMessage) -> str:
    if email_obj.is_multipart():
        parts = []
        for part in email_obj.walk():
            if part.get_content_maintype() == "multipart":
                continue
            if part.get_content_disposition() == "attachment":
                continue
            try:
                payload = part.get_payload(decode=True) or b""
                charset = part.get_content_charset() or "utf-8"
                text = payload.decode(charset, errors="ignore")
                if text.strip():
                    parts.append(text.strip())
            except Exception:
                continue
        return "\n".join(parts)
    try:
        payload = email_obj.get_payload(decode=True) or b""
        charset = email_obj.get_content_charset() or "utf-8"
        return payload.decode(charset, errors="ignore").strip()
    except Exception:
        return ""


def _extract_attachments(email_obj: EmailMessage, max_mb: int) -> List[Attachment]:
    attachments: List[Attachment] = []
    byte_limit = max_mb * 1024 * 1024
    for part in email_obj.walk():
        disposition = part.get_content_disposition()
        filename = part.get_filename()
        if disposition != "attachment" and not filename:
            continue
        try:
            payload = part.get_payload(decode=True) or b""
            if byte_limit > 0 and len(payload) > byte_limit:
                continue
            attachments.append(
                Attachment(
                    filename=filename or "attachment.bin",
                    content=payload,
                    content_type=part.get_content_type() or "",
                )
            )
        except Exception:
            continue
    return attachments


def _parse_raw_email(raw_bytes: bytes, config: BotConfig) -> InboundMessage:
    email_obj = message_from_bytes(raw_bytes)
    subject = _decode_subject(email_obj)
    body = _extract_body(email_obj)
    attachments = _extract_attachments(email_obj, config.general.max_attachment_mb)
    return InboundMessage(subject=subject, body=body, attachments=attachments)


def main(config_dir: Path | None = None) -> None:
    print("\n" + "="*60)
    print("MAILBOT PREMIUM v26 - STARTING")
    print("="*60)
    print(f"Log file: {LOG_PATH}\n")
    
    logger.info("=== MailBot v26 started ===")

    try:
        base_config_dir = config_dir or CURRENT_DIR / "config"
        config = load_config(base_config_dir)
        logger.info("Configuration loaded: %d accounts", len(config.accounts))
        print(f"✅ Loaded {len(config.accounts)} accounts")
    except Exception as exc:
        logger.exception("Failed to load configuration")
        print(f"❌ Configuration error: {exc}")
        time.sleep(10)
        return

    state = StateManager(CURRENT_DIR / "state.json")
    processor = MessageProcessor(config=config, state=state)
    print("✅ Ready to work\n")

    cycle = 0
    try:
        while True:
            cycle += 1
            print(f"\n{'='*60}")
            print(f"CYCLE #{cycle} - {time.strftime('%H:%M:%S')}")
            print(f"{'='*60}")
            logger.info("Cycle %d started", cycle)

            for account in config.accounts:
                login = account.login or "no_login"
                print(f"\n📧 Checking: {login}")

                try:
                    imap = ResilientIMAP(account, state)
                    new_messages = imap.fetch_new_messages()

                    if not new_messages:
                        print("   └─ no new messages")
                        continue

                    print(f"   └─ received {len(new_messages)} new messages")

                    for uid, raw in new_messages:
                        print(f"      ├─ UID {uid}")
                        try:
                            inbound = _parse_raw_email(raw, config)
                            subject = inbound.subject[:60] if inbound.subject else "(no subject)"
                            print(f"      │  Subject: {subject}")

                            final_text = processor.process(login, inbound)

                            if final_text and final_text.strip():
                                ok = send_telegram(
                                    config.keys.telegram_bot_token,
                                    account.telegram_chat_id,
                                    final_text.strip()
                                )
                                status = "✅ sent" if ok else "❌ failed"
                                print(f"      │  Telegram: {status}")
                                logger.info("UID %s: Telegram %s", uid, "OK" if ok else "FAIL")
                            else:
                                print(f"      │  Result: empty")

                        except Exception as e:
                            print(f"      └─ ❌ ERROR: {e}")
                            logger.exception("Processing error for UID %s", uid)

                    state.save()

                except Exception as e:
                    print(f"   └─ ❌ IMAP ERROR: {e}")
                    logger.exception("IMAP error for %s", login)

            state.save()
            delay = max(120, config.general.check_interval)
            print(f"\n⏳ Sleeping {delay} seconds...")
            time.sleep(delay)

    except KeyboardInterrupt:
        print("\n\n🛑 Stopped by user")
        logger.info("Stopped by user")
    except Exception as e:
        print(f"\n\n💥 CRITICAL ERROR: {e}")
        logger.exception("Fatal error")
        time.sleep(10)


if __name__ == "__main__":
    main()

------------------------------------------------------------

========== содержимое файла mailbot_v26\state_manager.py ==========

"""Thread-safe persistence for MailBot Premium v26.

The state file keeps track of processed UIDs and service health so the
pipeline can resume after restarts without duplicating work. The design
follows the Constitution's Guaranteed Mode: operations fail gracefully
and prefer safe defaults over crashes.
"""

from __future__ import annotations

import json
import threading
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any, Dict, Optional

DEFAULT_STATE_PATH = Path(__file__).resolve().parent / "state.json"


@dataclass
class AccountState:
    last_uid: int = 0
    last_check_time: Optional[str] = None
    imap_status: str = "unknown"
    last_error: str = ""


@dataclass
class LLMState:
    tokens_used_today: int = 0
    date: str = field(default_factory=lambda: datetime.now().strftime("%Y-%m-%d"))
    unavailable: bool = False
    last_error: str = ""


@dataclass
class MetaState:
    version: str = "v26"
    last_save: str = field(default_factory=lambda: datetime.now().isoformat())


@dataclass
class BotState:
    accounts: Dict[str, AccountState] = field(default_factory=dict)
    llm: LLMState = field(default_factory=LLMState)
    meta: MetaState = field(default_factory=MetaState)


class StateManager:
    """Persistent, thread-safe state handler."""

    def __init__(self, state_file: Path = DEFAULT_STATE_PATH) -> None:
        self.state_file = state_file
        self._lock = threading.Lock()
        self._state = self._load_state()
        self._dirty = False
        self._last_save_ts = datetime.now()

    def _load_state(self) -> BotState:
        if not self.state_file.exists():
            return BotState()
        try:
            with open(self.state_file, "r", encoding="utf-8") as fh:
                raw = json.load(fh)
        except (json.JSONDecodeError, OSError):
            return BotState()

        accounts = {
            login: AccountState(**data)
            for login, data in raw.get("accounts", {}).items()
        }
        llm_raw = raw.get("llm", {})
        meta_raw = raw.get("meta", {})
        return BotState(
            accounts=accounts,
            llm=LLMState(**llm_raw),
            meta=MetaState(**meta_raw),
        )

    def get_last_uid(self, login: str) -> int:
        with self._lock:
            return self._state.accounts.get(login, AccountState()).last_uid

    def update_last_uid(self, login: str, uid: int) -> None:
        with self._lock:
            account = self._state.accounts.setdefault(login, AccountState())
            account.last_uid = uid
            self._mark_dirty()

    def update_check_time(self, login: str, timestamp: Optional[datetime] = None) -> None:
        with self._lock:
            ts = (timestamp or datetime.now()).isoformat()
            account = self._state.accounts.setdefault(login, AccountState())
            account.last_check_time = ts
            self._mark_dirty()

    def get_last_check_time(self, login: str) -> Optional[datetime]:
        with self._lock:
            time_str = self._state.accounts.get(login, AccountState()).last_check_time
        if not time_str:
            return None
        return datetime.fromisoformat(time_str)

    def set_imap_status(self, login: str, status: str, error: str = "") -> None:
        with self._lock:
            account = self._state.accounts.setdefault(login, AccountState())
            account.imap_status = status
            account.last_error = error
            self._mark_dirty()

    def add_tokens(self, count: int) -> None:
        with self._lock:
            today = datetime.now().strftime("%Y-%m-%d")
            if self._state.llm.date != today:
                self._state.llm.tokens_used_today = 0
                self._state.llm.date = today
            self._state.llm.tokens_used_today += count
            self._mark_dirty()

    def set_llm_unavailable(self, unavailable: bool, error: str = "") -> None:
        with self._lock:
            self._state.llm.unavailable = unavailable
            self._state.llm.last_error = error
            self._mark_dirty()

    def save(self, force: bool = False) -> None:
        with self._lock:
            now = datetime.now()
            should_save = force or self._dirty or (now - self._last_save_ts) > timedelta(seconds=60)
            if not should_save:
                return

            payload = {
                "accounts": {login: account.__dict__ for login, account in self._state.accounts.items()},
                "llm": self._state.llm.__dict__,
                "meta": {**self._state.meta.__dict__, "last_save": now.isoformat()},
            }

            tmp_file = self.state_file.with_suffix(".tmp")
            with open(tmp_file, "w", encoding="utf-8") as fh:
                json.dump(payload, fh, indent=2, ensure_ascii=False)
            tmp_file.replace(self.state_file)
            self._dirty = False
            self._last_save_ts = now

    def _mark_dirty(self) -> None:
        self._dirty = True


__all__ = ["StateManager", "BotState", "AccountState", "LLMState", "MetaState"]


------------------------------------------------------------

========== содержимое файла mailbot_v26\tests\conftest.py ==========

import sys
from pathlib import Path

# Ensure repository root is on sys.path for test imports
ROOT = Path(__file__).resolve().parents[1]
PARENT = ROOT.parent
if str(PARENT) not in sys.path:
    sys.path.insert(0, str(PARENT))


------------------------------------------------------------

========== содержимое файла mailbot_v26\tests\test_config_loader.py ==========

from pathlib import Path

import pytest

from mailbot_v26.config_loader import (
    BotConfig,
    ConfigError,
    load_accounts_config,
    load_config,
    load_general_config,
    load_keys_config,
)


def write_file(tmpdir: Path, name: str, content: str) -> None:
    path = tmpdir / name
    path.write_text(content, encoding="utf-8")


def build_sample_config(tmpdir: Path) -> None:
    write_file(
        tmpdir,
        "config.ini",
        """[general]
check_interval = 400
max_attachment_mb = 20
admin_chat_id = 111
""",
    )
    write_file(
        tmpdir,
        "accounts.ini",
        """[primary]
login = sample@example.com
password = secret
host = imap.example.com
port = 993
use_ssl = true
telegram_chat_id = 222
""",
    )
    write_file(
        tmpdir,
        "keys.ini",
        """[telegram]
bot_token = token

[cloudflare]
account_id = acc
api_token = key
""",
    )


def test_load_full_config(tmp_path: Path) -> None:
    build_sample_config(tmp_path)
    cfg = load_config(tmp_path)
    assert isinstance(cfg, BotConfig)
    assert cfg.general.check_interval == 400
    assert cfg.accounts[0].login == "sample@example.com"
    assert cfg.keys.telegram_bot_token == "token"


def test_missing_files_raise() -> None:
    with pytest.raises(ConfigError):
        load_general_config(Path("/nonexistent"))


def test_accounts_missing_section(tmp_path: Path) -> None:
    write_file(tmp_path, "accounts.ini", "")
    with pytest.raises(ConfigError):
        load_accounts_config(tmp_path)


def test_general_default_interval(tmp_path: Path) -> None:
    write_file(
        tmp_path,
        "config.ini",
        """[general]
max_attachment_mb = 10
admin_chat_id = 1
""",
    )
    general = load_general_config(tmp_path)
    assert general.check_interval == 180


def test_general_interval_explicit_value(tmp_path: Path) -> None:
    write_file(
        tmp_path,
        "config.ini",
        """[general]
check_interval = 180
max_attachment_mb = 10
admin_chat_id = 1
""",
    )
    general = load_general_config(tmp_path)
    assert general.check_interval == 180


------------------------------------------------------------

========== содержимое файла mailbot_v26\tests\test_main_entrypoint.py ==========

import runpy

import mailbot_v26.start


def test_module_entrypoint_runs_start(monkeypatch):
    called = {}

    def fake_main(config_dir=None):
        called["config_dir"] = config_dir

    monkeypatch.setattr(mailbot_v26.start, "main", fake_main)

    runpy.run_module("mailbot_v26", run_name="__main__")

    assert called["config_dir"] is None


------------------------------------------------------------

========== содержимое файла mailbot_v26\tests\test_pipeline_processor.py ==========

from pathlib import Path

from mailbot_v26.config_loader import load_config
from mailbot_v26.pipeline.processor import Message, PipelineProcessor
from mailbot_v26.state_manager import StateManager


def test_pipeline_generates_compact_summary(tmp_path: Path) -> None:
    config_dir = tmp_path / "config"
    config_dir.mkdir()
    (config_dir / "config.ini").write_text("""[general]\ncheck_interval=100\nmax_attachment_mb=10\nadmin_chat_id=1\n""", encoding="utf-8")
    (config_dir / "accounts.ini").write_text("""[acc]\nlogin=a@b.com\npassword=p\nhost=imap\nuse_ssl=true\ntelegram_chat_id=1\n""", encoding="utf-8")
    (config_dir / "keys.ini").write_text("""[telegram]\nbot_token=t\n\n[cloudflare]\naccount_id=c\napi_token=k\n""", encoding="utf-8")

    config = load_config(config_dir)
    processor = PipelineProcessor(config, StateManager(tmp_path / "state.json"))
    summary = processor.process(
        account_login=config.accounts[0].login,
        message=Message(subject="Счет 321", body="Оплатить 12000 руб до 01.01.2025"),
    )
    assert summary.startswith("SUBJECT:")
    assert "none" not in summary.lower()
    assert len(summary) <= 240


def test_pipeline_falls_back_to_subject_when_no_facts(tmp_path: Path) -> None:
    config_dir = tmp_path / "config"
    config_dir.mkdir()
    (config_dir / "config.ini").write_text("""[general]\ncheck_interval=100\nmax_attachment_mb=10\nadmin_chat_id=1\n""", encoding="utf-8")
    (config_dir / "accounts.ini").write_text("""[acc]\nlogin=a@b.com\npassword=p\nhost=imap\nuse_ssl=true\ntelegram_chat_id=1\n""", encoding="utf-8")
    (config_dir / "keys.ini").write_text("""[telegram]\nbot_token=t\n\n[cloudflare]\naccount_id=c\napi_token=k\n""", encoding="utf-8")
    config = load_config(config_dir)

    processor = PipelineProcessor(config, StateManager(tmp_path / "state.json"))
    summary = processor.process(
        account_login=config.accounts[0].login,
        message=Message(subject="Обновление", body="Привет"),
    )
    assert summary == ""


------------------------------------------------------------

========== содержимое файла mailbot_v26\tests\test_state_manager.py ==========

from datetime import datetime
from pathlib import Path

from mailbot_v26.state_manager import StateManager


def test_state_persistence(tmp_path: Path) -> None:
    state_path = tmp_path / "state.json"
    manager = StateManager(state_path)
    manager.update_last_uid("user@example.com", 10)
    manager.update_check_time("user@example.com", datetime(2024, 1, 1))
    manager.add_tokens(50)
    manager.save(force=True)

    manager2 = StateManager(state_path)
    assert manager2.get_last_uid("user@example.com") == 10
    ts = manager2.get_last_check_time("user@example.com")
    assert ts is not None and ts.year == 2024
    assert manager2._state.llm.tokens_used_today >= 50


def test_llm_unavailable_flag(tmp_path: Path) -> None:
    manager = StateManager(tmp_path / "state.json")
    manager.set_llm_unavailable(True, "maintenance")
    manager.save(force=True)
    reloaded = StateManager(tmp_path / "state.json")
    assert reloaded._state.llm.unavailable is True
    assert reloaded._state.llm.last_error == "maintenance"


------------------------------------------------------------

========== содержимое файла mailbot_v26\tests\test_telegram_sender.py ==========

import logging
from types import SimpleNamespace

import pytest

from mailbot_v26.worker import telegram_sender


class DummyResponse:
    def __init__(self, status_code: int = 200, text: str = "ok") -> None:
        self.status_code = status_code
        self.text = text
        self.content = text.encode()


def test_send_telegram_empty_text_logs(caplog: pytest.LogCaptureFixture) -> None:
    with caplog.at_level(logging.ERROR):
        assert telegram_sender.send_telegram("token", "chat", "") is False
    assert "empty" in caplog.text.lower()


def test_send_telegram_success(monkeypatch: pytest.MonkeyPatch) -> None:
    called = {}

    def fake_post(url: str, data: dict, timeout: int) -> DummyResponse:
        called["url"] = url
        called["data"] = data
        called["timeout"] = timeout
        return DummyResponse(status_code=200, text="ok")

    monkeypatch.setattr(telegram_sender, "requests", SimpleNamespace(post=fake_post))
    assert telegram_sender.send_telegram("token", "123", "hello") is True
    assert called["data"]["text"] == "hello"
    assert called["data"]["chat_id"] == "123"


def test_send_telegram_non_200_logs(monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -> None:
    monkeypatch.setattr(
        telegram_sender,
        "requests",
        SimpleNamespace(post=lambda url, data, timeout: DummyResponse(status_code=500, text="bad")),
    )
    with caplog.at_level(logging.ERROR):
        assert telegram_sender.send_telegram("token", "123", "hello") is False
    assert "status 500" in caplog.text


def test_send_telegram_exception(monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -> None:
    def raising_post(url: str, data: dict, timeout: int) -> DummyResponse:
        raise RuntimeError("network error")

    monkeypatch.setattr(telegram_sender, "requests", SimpleNamespace(post=raising_post))
    with caplog.at_level(logging.ERROR):
        assert telegram_sender.send_telegram("token", "123", "hello") is False
    assert "network error" in caplog.text


def test_send_telegram_requests_missing(monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -> None:
    monkeypatch.setattr(telegram_sender, "requests", None)
    with caplog.at_level(logging.ERROR):
        assert telegram_sender.send_telegram("token", "123", "hello") is False
    assert "requests library is not available" in caplog.text


------------------------------------------------------------

========== содержимое файла mailbot_v26\worker\telegram_sender.py ==========

import importlib.util
import logging
from typing import Any

requests_spec = importlib.util.find_spec("requests")
if requests_spec is not None:
    import requests  # type: ignore
else:
    requests = None


def _get_logger() -> logging.Logger:
    return logging.getLogger(__name__)


def send_telegram(bot_token: str, chat_id: str, text: str) -> bool:
    logger = _get_logger()
    text = (text or "").strip()
    if not text:
        logger.error("Telegram message text is empty; skipping send")
        return False

    if requests is None:
        logger.error("requests library is not available; cannot send Telegram message")
        return False

    token = (bot_token or "").strip()
    target_chat = (chat_id or "").strip()
    if not token:
        logger.error("Telegram bot token is empty or invalid")
        return False
    if not target_chat:
        logger.error("Telegram chat_id is empty or invalid")
        return False

    url = f"https://api.telegram.org/bot{token}/sendMessage"
    data = {"chat_id": target_chat, "text": text[:4000]}

    try:
        resp = requests.post(url, data=data, timeout=10)
    except Exception as exc:  # pragma: no cover - network errors
        logger.exception("Telegram request failed: %s", exc)
        return False

    if resp.status_code != 200:
        body: Any = getattr(resp, "text", None) or getattr(resp, "content", b"")
        logger.error("Telegram returned status %s with body: %s", resp.status_code, body)
        return False

    return True


def _self_test():
    # We cannot hit real Telegram here.
    # Just test that empty text is not sent.
    assert send_telegram("dummy", "123", "") is False
    assert send_telegram("dummy", "123", "   ") is False
    print("OK: telegram_sender self-test passed (logic only)")


if __name__ == "__main__":
    _self_test()


------------------------------------------------------------

